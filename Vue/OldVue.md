

# 一、简介

## 1.1 什么是Vue

Vue是一套**用于构建用户界面**的渐进式JavaScript前端**框架**

1. 构建用户界面
   - 用vue往html页面中填充数据
2. 框架
   - 框架是以套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能
   - 学习vue，就是在学习vue框架中规定的用法
   - vue的指令、组件（是对UI结构的复用）、路由、Vuex、vue组件库

## 1.2 Vue的特性

> vue框架的特性，主要体现在如下两方面：

### 1.2.1 数据驱动视图

- 在使用了vue的页面中，vue会**监听数据的变化**，从而**自动**重新渲染页面的结构（数据的变化会**驱动视图**自动更新）

  1. 好处：当页面数据发生变化时，页面会自动重新渲染

  2. 注意：数据驱动视图是**单向的数据绑定**	

  3. 示意图如下![](http://127.0.0.1:8888/uploads/202302222241603.png)

### 1.2.2 双向数据绑定	

> 在网页中，form表单负责**采集数据**，Ajax负责**提交数据**

- 在**填写表单**时，双向数据绑定可以辅助开发者在**不操作DOM的前提下**，**自动**把用户填写的内容同步到数据源中
  1. js数据的变化，会被自动渲染到页面上
  2. 页面上表单采集的数据发生变化的时候，会被vue自动获取到，并更新到js数据中
  3. 好处：开发者不再需要手动操作DOM元素，来获取表单元素最新的值
  4. 示意图如下![](http://127.0.0.1:8888/uploads/202302222259377.png)

![](http://127.0.0.1:8888/uploads/202302222300626.png)

## 1.3 MVVM

- MVVM是vue实现数据驱动视图和双向数据绑定的核心原理。MVVM指的是 **M**odel（数据源）、**V**iew （视图）和 **V**iew**M**odel（就是vue的实例），它把每个HTML页面都拆分成了这三个部分，如图所示：![](http://127.0.0.1:8888/uploads/202302222316507.png)

- 在MVVM概念中：
  1. **Model**表示当前页面渲染时所依赖的数据源
  2. **View**表示当页面所渲染的DOM结构
  3. **ViewModel**表示vue的实例，它是MVVM的核心

### 1.3.1 MVVM的工作原理

- **ViewModer作为MVVM的核心**，是它把当前页面的**数据源**（Model）和**页面的结构**（View）连接在了一起![](http://127.0.0.1:8888/uploads/202302222329260.png)

  - 当**数据源发生变化**时，会被ViewModel监听到，VM会根据最新的数据源**自动更新**页面的结构

  - 当**表单元素的值发生变化**时，也会被VM监听到，VM会把变化以后最新的值**自动同步**到Model数据源中


------

# 基础用法

1. 使用Vue，首先导入Vue库文件，就能使用Vue构造函数
2. vue库文件网址： https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js
3. 示例

   ```vue
   <body>
        <!-- 在页面中声明一个将要被 vue 所控制的 DOM 区域-->
        <div id="app">{{ username }}</div>
   
        <!-- 导入Vue的库文件，在window全局就有了vue这个构造函数 -->
        <script src="vuejs/vue.js"></script>
   
        <script>
       // 创建 vue 的实例对象
        const vm = new Vue({
           // el属性是固定的写法，表示当前 vm 实例要控制页面上的哪个区域
           el:'#app',
           // data 对象就是要渲染到页面上的数据
           data:{
               username:'张三'
           }
        })
   
       </script>
   </body>
   ```

基本代码与MVVM的对应关系![](http://127.0.0.1:8888/uploads/202302231445888.jpg)


------

# 内容渲染指令

**内容渲染指令**用来辅助开发者**渲染DOM元素的文本内容**

## v-text

- `v-text`指令的缺点：会覆盖元素内部原有的内容
- 用法示例![](http://127.0.0.1:8888/uploads/202302232101080.png) 

## {{ }}语法

1. vue提供的 **{{ }}** 语法，专门用来解决 v-text 会覆盖默认文本内容的问题。这种 {{ }} 语法的专业名称是 **插值表达式** （英文名为：Mustache）
2. {{ }}插值表达式：在实际开发中用的最多，只是内容的占位符，不会覆盖原有的内容
   - 用法示例![](http://127.0.0.1:8888/uploads/202302232118438.png)

## v-html

1. v**-text**指令和插值表达式只能**渲染纯文本内容**。如果要把**包含HTML标签的字符串**渲染为页面的HTML元素，则需要用到v-html这个指令
2. `v-html`指令的作用：可以把带有标签的字符串，渲染成真正的HTML内容
   - 用法示例![](http://127.0.0.1:8888/uploads/202302232129456.png)

------

# 属性绑定指令（单向数据绑定）

1. 插值表达式只能用在元素的**内容节点**中，不能用在元素的**属性节点**中
2. 在vue中，可以使用 `v-bind: `指令为**元素的属性**动态绑定**属性值**指令
3. `v-bind: `指令可以简写为英文的 “ `:` ”
   - 用法示例![](http://127.0.0.1:8888/uploads/202302232326124.png)

------

# 双向绑定指令

1. vue提供了 **v-model 双向数据绑定**指令，
2. 用来辅助开发者在**不操作DOM**的前提下，一般都应用在**获取表单的数据**
3. v-model:value 可以简写为 v-model，v-model默认收集的就是value值
4. 示例![](http://127.0.0.1:8888/uploads/202302242013928.gif)

## v-model 指令的修饰符

1. 为了方便对用户输入的内容进行处理，vue为v-model指令提供了3个修饰符

2. 修饰符

   | 修饰符  | 作用                                             |
   | ------- | ------------------------------------------------ |
   | .number | 自动将用户的输入值转为数值类型                   |
   | .trim   | 自动过滤用户输入的首尾空白字符（中间则无法去除） |
   | .lazy   | 在”change“是而非”input“时更新（防抖）            |

3. 代码演示![](http://127.0.0.1:8888/uploads/202302242107787.gif)

------

# v-bind 和 v-model 的区别

- Vue中有2种数据绑定的方式
  1. **单向的数据绑定（v-bind）**：数据只能从data流向页面
  2. **双向数据绑定（v-model）**：数据不仅能从data流向页面，还可以从页面流向data
- 代码演示![](http://127.0.0.1:8888/uploads/202302242023623.gif)

------

# 在插值和属性中编写JS语句

### 使用javascript表达式

- 在vue提供的模板渲染语法中，除了支持绑定**简单的数据值**之外，还支持**javascript表达式的运算**

  ```javascript
  {{ number + 1 }}			// 可以使用js里面的运算符
  {{ ok ? 'YES' : 'NO'}}		// 三元运算符
  {{ message.split('').reverse().join('') }}		// 函数 或 方法
  
  // 在使用 v-bind 属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号
  <div v-bind:id="'box' + id"></div>		// 字符串拼接
  ```

  - 代码演示![](http://127.0.0.1:8888/uploads/202302240023745.png)

------

# 事件绑定指令

- vue提供了 **v-on事件绑定**指令，用来辅助程序员为DOM元素绑定事件监听

  - 语法格式为：

  ```javascript
  // v-on:绑定事件 = "事件名"
  // 简写v-on:指令：@绑定事件 = "事件名"
  
  <button> @click = "add"></button>
  
  methods:{
  	add(){
  	// 如果在方法中修改 data 中的数据，可以通过 this 访问到
  	this.count += 1
  	}
  }
  ```

## 定义事件的处理函数

- 原生DOM对象有onclick、oninput、onkeyup等原生事件，替换为vue的事件绑定形式后，**分别为：v-on:click、v-on:input、v-on:keyup**
- 演示![](http://127.0.0.1:8888/uploads/202302241330142.gif)

## 定义事件的处理函数（传参）

- 演示![](http://127.0.0.1:8888/uploads/202302241338023.gif)

## 使用js的表达式

- 演示![](http://127.0.0.1:8888/uploads/202302241344220.gif)

## 事件对象$event

1. \$event的应用场景：如果**默认的事件对象 e** 被覆盖了，则可以手动传递一个 $event

2. 语法格式为：

   ```vue
   <button @click = "add(2,$event)"></button>
   
   methods:{
   	add(n,e){
   		// 如果在方法中要修改 data 中的数据，可以通过 this 访问到
   		this.count += n
   	}
   }
   ```

   - 演示![](http://127.0.0.1:8888/uploads/202302241438839.gif)

## 事件修饰符

- 在事件处理函数中调用 `event.preventDefault()` 或 `event.stopPropagation() `是非常常见的需求。因此，vue提供了**事件修饰符**的概念，来辅助程序员更方便的**对事件的触发进行控制**

- 常用事件如下

  | 事件修饰符 | 说明                                                         |
  | ---------- | ------------------------------------------------------------ |
  | .prevent   | 阻止默认行为（例如：阻止a链接的跳转、阻止表单的提交等）（重点） |
  | .stop      | 阻止事件冒泡（重点）                                         |
  | .capture   | 以捕获模式触发当前的事件处理函数                             |
  | .once      | 绑定的事件只触发1次                                          |
  | .self      | 只有在 event.target 是当前元素自身是触发事件处理函数         |

  - 代码演示![](http://127.0.0.1:8888/uploads/202302241618456.gif)

### 按键修饰符

- 在监听**键盘事件**时，可以为**键盘相关的事件**添加**按键修饰符**，来**判断详细的按键**

- 语法格式为：

  ```vue
  <!--只有在‘key’是'Enter'时调用‘vm.submit()’-->
  <input @keyup.enter = "submir">
  
  <!-- 只有在‘key’ 是 'Esc' 时调用‘vm.clearInput()’-->
  <input @keyup.esc = "clearInput">
  
  ```

  - 示例![](http://127.0.0.1:8888/uploads/202302241700988.gif)

------

# 条件渲染指令

**条件渲染指令**用来辅助开发者**按需控制 DOM 的显示与隐藏**

1. `v-show`的原理：动态为元素添加或移除`display:none`样式，来实现元素的显示和隐藏

   - 如果要频繁的切换元素的显示状态，用 v-show 性能更好

2. `v-if`的原理：每次动态创建或移除元素，实现元素的显示和隐藏

   - 如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时 v-if 性能更好

     ![](http://127.0.0.1:8888/uploads/202302242312209.gif)

3. `v-else`：v-if可以单独使用，或配合 v-else 指令一起使用。v-else 指令必须配合 v-if 指令一起使用，否则它将不会被识别

   - 语法

     ```vue
     <div v-if = 'Math.random() > 0.5'>
         随机数大于0.5
     </div>
     
     <div v-else>
         随机数小于等于 0.5
     </div>
     ```

4. `v-else-if`指令：充当 v- if 的 ” else-if 快“，可以连续使用。v-else-if 指令必须配合 v-if 指令一起使用，否则它将不会被识别

   - 语法

     ```vue
     <div v-if="type === 'A'">优秀</div>
     <div v-else-if="type === 'B'">良好</div>
     <div v-else-if="type === 'C'">一般</div>
     <div v-else>差</div>
     ```

   - 代码演示![](http://127.0.0.1:8888/uploads/202302242358991.gif)

------

# 列表渲染指令

vue提供了 v-for 列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构

官方建议：使用 v-for指令，一定要添加 key 属性

1. v-for 指令需要使用 item in items 形式的特殊语法，其中：

     - items 是待循环的数组（items为变量名（可自起））

     - item 是被循环的每一项（item为变量名（可自起））

     - 语法格式为

       ```vue
       data:{
       	list:[ // 列表数据
       		{id: 1, name: 'zs'},
       		{id: 2, name: 'ls'}
       	]
       }
       //-------------分割--------------
       <ul>
       	<li v-for = "item in list">姓名是:{{ item,name }}</li>
       </ul>
       ```

2. v-for 指令还支持一个可选的第二个参数，即当前项的索引

     - 语法格式： `(item, index) in items`（变量名可自起）

     - v-for指令中的 **item项** 和 **index索引** 都是形参，可以根据需要进行**重命名**。例如(user, i) in userlist

       ```vue
       data:{
       	list:[ // 列表数据
       		{id: 1, name: 'zs'},
       		{id: 2, name: 'ls'}
       	]
       }
       //-------------分割--------------
       <ul>
       	<li v-for = "(item, index)in list">索引：{{ index }},姓名是:{{ item,name }}</li>
       </ul>
       ```

       ![](http://127.0.0.1:8888/uploads/202302251624175.png)

3. key

   - 建议使用 v-for命令时一定要指定 key 的值（既提升性能，又防止列表状态紊乱）

   - key 的值只能是**字符串**或**数字类型**

   - key 的值**必须具有唯一性**（即：key的值不能重复）

   - 建议把数字项 id 属性的值作为key的值（id属性的值具有唯一性）

   - 示例

     ![](http://127.0.0.1:8888/uploads/202302251627003.png)

# 过滤器

## 过滤器的基本使用

1. **过滤器（Filters**）是vue为开发者提供的功能，常用于**文本的格式化**。过滤器可以用在两个地方：**插值表达式**和 v**-bind 属性绑定**

2. 过滤器应该被添加在JavaScript表达式的尾部，由 “ 管道符” 进行调用

3. 在过滤器函数中，一定要有 retern 值

4. 在过滤器的形参中，就可以获取“管道符”前面待处理的那个值

5. 过滤器的基本使用

   ```vue
   <!-- 在双花括号中通过“管道符”调用 capitalize 过滤器，对 message 的值进行格式化-->
   <p>{{ message | capitalize }}</p>
   
   <!-- 在 v-bind 中通过“管道符”调用 formatId 过滤器，对 rawId 的值进行格式化-->
   <div v-bind:id="rawId | formatId"></div>
   ```

   ![](http://127.0.0.1:8888/uploads/202302262216444.png)

## 私有过滤器和全局过滤器

1. 在 filters 节点下定义的过滤器，称为“**私有过滤器**”，因为它**只能在当前vm实例所控制的el区域内使用**

2. 如果希望**在多个vue实例之间共享过滤器**，则可以按照如下的格式定义**全局过滤器**：

   ```vue
   // 全局过滤器 - 独立于每个 vm 实例之外
   // Vue.filter() 方法接收两个参数
   // 	第 1 个参数，是全局过滤器的“名字”
   // 	第 2 个参数，是全局过滤器的“处理函数”，function(任起名) 括号内为管道符前面的值
   
   
   Vue.filter('capitalize', function(str){
    return 返回的值
   })
   ```

3. 全局过滤器需要声明到创建实例前，否则会报错

4. 如果全局过滤器和私有过滤器名字一致，此时按照“就近原则”，调用的是“私有过滤器”![](http://127.0.0.1:8888/uploads/202302271139296.png)

## 连续调用多个过滤器

- 过滤器可以串联地进行调用，例如

  ```
  <!-- 把 message 的值，交给 filterA 进行处理-->
  <!-- 把 filterA 处理的结果，再交给 filterB 进行处理>
  <!-- 最终把 filter 处理的结果，作为最终的值渲染到页面上>
  {{ message | filterA | filterB }}
  ```

## 过滤器传参

- 过滤器的本质是JavaScript函数，因此可以接收参数

  ```javascript
  <!-- arg1 和 arg2 是传递给 filterA 的参数 -->
  <p>{{ message | filterA(arg1, arg2) }}</p>
  
  // 过滤器处理函数的形参列表中
  // 第一参数：永远都是“管道符”前面待处理的值
  // 从第二个参数开始，才是调用过滤器时传递过来的 arg1 和 arg2 参数
  
  Vue.filter('filterA',(msg,arg1,arg2){
  	// 过滤器的代码...
  })
  ```


------

# 侦听器

## watch侦听器

- **watch侦听器**允许开发者监视数据的变化，从而**针对数据的变化做特定的操作**

  - 语法

    ```javascript
    const vm = new Vue({
    	el:'#app',
       	data:{
         	username:''
       	},
       // 所有的侦听器，都应该被定义到 watch 节点下
       	watch:{
           	username(newval,oldval){
               	// 侦听器本质上是一个函数，要监听哪个数据的变化，就把数据名作为方法名即可
               	console.log('监听到username值的变化','新值：',newval,'旧值：',oldval)
           	}
       	}
    })
    ```

    - 示例![](http://127.0.0.1:8888/uploads/202302272042543.gif)

## immediate 控制侦听器是否自动触发

- 默认情况下，组件在初次加载完毕后不会调用 watch 侦听器，如果想让 watch 侦听器立即被调用，则需要使用 `immediate`选项

- 使用侦听器的格式

  - 使用**方法（函数）格式**的侦听器无法在刚进入页面的时候，自动触发
  - 使用**对象**的侦听器可以通过 immediate 选项，进入页面让侦听器自动触发

- immediate属性值

  | 值    | 说明                                                   |
  | ----- | ------------------------------------------------------ |
  | true  | 页面初次渲染好之后，就立即触发当前的 watch侦听器       |
  | false | 默认值，页面初次渲染好之后，不会触发当前的 watch侦听器 |

  - 代码

    ```javascript
    // 创建 Vue 的实例对象
    const vm = new Vue({
        el:'#app',
        data:{
          username:'admin'
        },
        // 所有的侦听器，都应该被定义到 watch 节点下
        watch:{
            username:{
                handler(newval,oldval){
                // 侦听器本质上是一个函数，要监听哪个数据的变化，就把数据名作为方法名即可
                    console.log(newval,oldval)
                },
                // immediate默认值为 false
                // 页面初次渲染好之后，就立即触发当前的 watch侦听器
                immediate: true
            }
        }
     })
    ```

## deep 选项

- 如果watch侦听的是一个对象，如果对象里面属性的变化，则不会被watch侦听器所监听到。如果想让监听到对象里面的属性，则需要使用 `deep`选项

- 使用侦听器的格式

  - 使用**方法（函数）**格式如果侦听的是一个对象，对象中的属性发生了变化不会触发侦听器

  - 使用对象的侦听器可以通过 deep 选项，可以让侦听器深度监听对象中每个属性的变化

- deep属性值

  | 值    | 说明                                                         |
  | ----- | ------------------------------------------------------------ |
  | true  | 开启深度监听，只要对象中任何一个属性发生变化，都会触发对象的侦听器 |
  | false | 默认值。关闭深度监听                                         |

- 示例

  ```javascript
  // 创建 Vue 的实例对象
  const vm = new Vue({
  	el:'#app',
  	data:{
  		// 用户的信息对象
  		info:{
  			username:'admin'
  		}
  	},
  // 所有的侦听器，都应该被定义到 watch 节点下
  	watch:{
          info:{
            handler(newval){
               console.log(newval)
             },   
      // 开启深度监听，只要对象中任何一个属性发生变化，都会触发“对象的侦听器”
                 deep: true
              }
          }
       })
  ```

## 侦听对象的子属性

- 如果要侦听对象里面的单个子属性，则需要添加单引号或双引号

- 示例

  ```javascript
  // 创建 Vue 的实例对象
  const vm = new Vue({
      el:'#app',
      data:{
          // 用户的信息对象
          info:{
              username:'admin'
        	}
      },
      // 所有的侦听器，都应该被定义到 watch 节点下
      watch:{
          // 要侦听对象的子属性的变化，则必须包裹一层单引号或双引号
          "info.username"(newval){
              console.log(newval)   
          }
      }
   })
  ```

------

# 计算属性

- 计算属性指的是**通过一系列运算**之后，最终得到一个**属性值**

- 这个动态计算出来的属性值可以被模板结构 methods 方法使用

- 好处

  1. 实现了代码的复用

  2. 只要计算属性中依赖的数据源变化了，则计算属性会自动重新求值

- 示例

  ```vue
  <style>
      .box{
          width: 200px;
          height: 200px;
      }
  </style>
  <body>
      <div id="app">
          <span>R:</span>
          <input type="text" v-model.numder = "r">
          <span>G:</span>
          <input type="text" v-model.numder = "g">
          <span>B:</span>
          <input type="text" v-model.numder = "b">
          <div class="box" :style="{backgroundColor:rgb}">
              {{rgb}}
          </div>
      </div>
      <script>
          const vm = new Vue({
              el:'#app',
              data:{
                  r:0,
                  g:0,
                  b:0
              },
              computed:{
                  // rgb 作为一个计算属性，被定义成了方法格式
                  // 最终，在这个方法中，要返回一个生成好的 rgb(x,x,x)的字符                
                  rgb(){
                      return `rgb(${this.r},${this.g},${this.b})`
                  }
              }
          })
      </script>
  </body>
  ```


# axios

> axios是一个专注于网络的库
